##### 엔티티 설계시 주의점
1. 엔티티에는 가급적 Setter를 사용하지 말자.
    - Setter를 열어두게되면 엔티티가 변경되는 포인트가 많아져 유지보수가 어려워진다.
2. 모든 연관관계는 지연로딩으로 설정
    - 즉시로딩은 어떤 SQL이 실행될지 예측하기 어렵다. (최악의 상황에서는 연관된 모든 데이터를 모두 가져와서 메모리 부족이 발생가능)
    - 연관된 엔티티를 함께 조회해야 한다면 fetch join 또는 엔티티 그래프 기능 사용
3. 컬렉션은 필드에서 초기화하자.
    - ```java
      @OneToMany(mappedBy = "order")
      private List<OrderItem> orderItems = new ArrayList<>();
      ```
    - 필드에서 초기화 하는것이 가장 안전하고, 코드도 간결하다.

##### 변경 감지 (dirty checking)와 병합 (merge)
* 준영속 엔티티
    - 영속성 컨테이너에서 더이상 관리되지 않는 엔티티
    - 준영속 엔티티를 수정하는 2가지 방법
        1. 변경 감지 기능 사용 (추천)
            - 영속 상태로 만든 후 변경 감지가 되도록
        2. 병합 (merge) 사용 (모든 속성이 변경되는 등 위험성이 있으므로 가급적 병합은 사용하지 않는다.)
            - 준영속 상태의 엔티티를 영속 상태로 변경한다.
            - 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다. (주의 특정 필드가 null인 상태로 병합되면 DB에 null로 저장 됨.)


##### 컬렉션 엔티티 + 페이징 조회
- 1:N 관계(컬렉션 엔티티)는 DB 데이터가 N만큼 증가되서 나오기 때문에 fetch join을 이용한 페이징이 어렵다(메모리에 올려진 상태에서 페이징 함, out of memory 발생이 가능하므로 위험하다.)
- 아래와 같은 방법으로 최적화를 할 수 있다.
    1. XToOne(OneToOne, ManyToOne) 관계를 모두 fetch join 한다. (XToOne 관계는 DB 데이터가 증가되지 않으므로 페이징 쿼리에 영향을 주지 않는다.)
    2. 컬렉션은 지연 로딩으로 조회한다.
    3. 지연 로딩 성능 최적화를 위해 `default_batch_fetch_size` 프로퍼티를 지정한다. 이 옵션을 사용하면 컬렉션을 설정한 SIZE만큼 IN 조건을 이용하여 조회를한다.
    - 즉 XToOne 관계는 fetch join을 해도 페이징에 영향을 주지 않는다. 페이징으로 쿼리 수를 줄이고 나머지는 batch_size로 최적화 하는것.
    - `default_batch_fetch_size`는 100~1000 사이를 선택하는것을 권장 (1000 이상은 DB에서 오류 또는 부하의 문제가 있을수 있다.)

##### 최적화 권장 순서
1. 엔티티 조회 방식으로 접근
    1. 페치조인 + 페이징으로 조회 수 최적화 (XToOne)
    2. 컬렉션 최적화
        1. 페이징 필요하다면 `default_batch_fetch_size`로 최적화
        2. 페이징 필요없다면 페치 조인 사용
    3. 조회된 엔티티를 DTO로 변환하여 리턴
2. 1이 안된다면 DTO 조회 방식으로 접근 (리턴할 컬럼을 선택할 수 있는 장점이 있다.)
3. 2가 안된다면 NativeSQL 또는 JdbcTemplate 사용
- 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야한다. 속도가 빠른 코드일지라도 복잡하여 유지보수가 힘들수 있다. 줄타기를 잘하자.
- 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에 단순한 코드를 유지하면서, 성능 최적화를 할 수 있다.
- DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에 최적화와 코드 복잡도 사이에서 잘 선택을 해야한다.

##### OSIV와 성능 최적화
- Open Session In View (하이버네이트) == Open EntityManager In View (JPA)
- OSIV 전략은 트랜잭션 시작시 데이터 베이스 커넥션을 가져와 응답(Response)이 끝날 때 까지 영속성 컨택스트와 데이터베이스 커넥션을 유지한다.
- 오랜 시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄수 있다. (결국 장애 요소)
- OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨택스트와 데이터베이스 커넥션을 반환한다. 하지만 모든 지연로딩을 트랜잭션 안(Service, Repository 계층에서)에서 처리해야 한다.
- `spring.jpa.open-in-view` 기본값 = true


#### Reference
실전! 스프링 부트와 JPA 활용1.김영한.인프런강의